# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_model.ipynb.

# %% auto 0
__all__ = ['Model']

# %% ../nbs/04_model.ipynb 5
from collections import defaultdict
import pandas as pd
# import matplotlib as mpl
# import matplotlib.pyplot as plt
from copy import copy
# import time
# import math
# from pprint import pprint
## !pip install -U "ray"
# import ray
# import json

from fastcore.basics import patch
import aishiftscheduler.config as cf
# import aishiftscheduler.policy as pol
import aishiftscheduler.visualization as vis

# %% ../nbs/04_model.ipynb 7
pd.options.display.float_format = '{:,.4f}'.format
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
pd.set_option('display.max_colwidth', None)

# %% ../nbs/04_model.ipynb 26
class Model(): pass

# %% ../nbs/04_model.ipynb 27
@patch
def __init__(self:Model, pars, W_fn=None, S__M_fn=None, C_fn=None):
    self.params = pars
    self.S_t = {
      'R_t': pd.DataFrame({
        'ResourceId': pars.RESOURCE_IDS,
        'Type': pars.TYPES,
        'RAvail_t': pars.get_availabilities(pd.to_datetime(pars.START_DATE_TIME)),
        'RCumSlots_t': [0]*len(pars.TYPES), ##cumulative allocs (for T)
        # /////////////////////
        ## 'RMonthCumSlots_t': [0]*len(cf.TYPES),
        ## 'RWeekCumSlots_t': [0]*len(cf.TYPES),
        ## 'RUtil_t': [0]*len(cf.TYPES),
        # \\\\\\\\\
        'RCumMerits_t': [0]*len(pars.TYPES),
        'RComplete_t': [0]*len(pars.TYPES), ## 1/0: daily slot-run complete or not
      }),
      'D_t': pd.DataFrame({ ## Demands
        'Type': pars.RESOURCE_TYPES,
        ## base demand, due to D_n
        'DSlot_t': [1]*len(pars.RESOURCE_TYPES), ##why 1?
        ## demand due to busyness, i.e. foot traffic
        'DBusy_t': [0]*len(pars.RESOURCE_TYPES), 
        ## demand due to volume, number of items seems to correlate best with demand in general
        'DVolume_t': [0]*len(pars.RESOURCE_TYPES),
        ## demand due to revenue, e.g. high-value items requires more staff for approval for returns 
        'DRevenue_t': [0]*len(pars.RESOURCE_TYPES),
        ## demand max due to all sources
        'DMax_t': [0]*len(pars.RESOURCE_TYPES), 
      }),
      'M_t': pd.DataFrame({ ## Merits
        'ResourceId': pars.RESOURCE_IDS,
        'Type': pars.TYPES,
        'nMerits_t': [0]*len(pars.TYPES),
      }),
      'B_t': pd.DataFrame({ ## Busyness
        'Busy_t': [0],
      }),
      'V_t': pd.DataFrame({ ## Volume
        'Volume_t': [0],
      }),
      'N_t': pd.DataFrame({ ## Revenue
        'Revenue_t': [0],
      }),      
      'xAlloc_t_1': pd.DataFrame({ ##previous allocation
        'Comb': pars.abNAMES, ##Combination
        'Allocd_t': [False]*len(pars.abNAMES), ##Allocated
      }),
    }
    self.x_t = {
      'xAlloc_t': pd.DataFrame({
        'Comb': pars.abNAMES, ##Combination
        'Allocd_t': [False]*len(pars.abNAMES), ##Allocated
      }),
    }
    self.Ccum_CumSlots = 0.0
    self.Ccum_SickProb = 0.0
    self.Ccum_CumMerits = 0.0
    self.Ccum_ContSlots = 0.0
    self.Ccum = 0.0 ##cumulative reward

    self.Ucum_Total = 0 ##cumulative unallocated/unmet demands
    ##cumulative unallocated/unmet demands
    self.Ucum = {rt: 0 for rt in pars.RESOURCE_TYPES}
    self.W_tt1 = {}

# %% ../nbs/04_model.ipynb 30
@patch
def W_fn(self:Model, t, dt): ## exogenous information
    return {
      ## 'demands': DEM.simulate(),
      ## 'demands': {'Courtesy': 2, 'Stocker': 1},
      'demands': { ## TAB function
        self.params.RESOURCE_TYPES[int(col.split('_')[1])]: cf.EXOG_INFO.loc[cf.EXOG_INFO['Date'] == dt, col].squeeze() 
        for col in [f'D_{d}' for d in range(len(self.params.RESOURCE_TYPES))]
      },
      ## 'merits': MER.simulate(),
      'merits': { ## TAB function
        self.params.aNAMES[int(col.split('_')[1])]: cf.EXOG_INFO.loc[cf.EXOG_INFO['Date'] == dt, col].squeeze() 
        for col in [f'M_{m}' for m in range(len(self.params.RESOURCE_IDS))]
      },
      'availabilities': self.params.get_availabilities(dt), ## TAB function
      'busyness': cf.EXOG_INFO.loc[cf.EXOG_INFO['Date'] == dt, 'busyness'].squeeze(),
      'volume': cf.EXOG_INFO.loc[cf.EXOG_INFO['Date'] == dt, 'volume'].squeeze(),
      'revenue': cf.EXOG_INFO.loc[cf.EXOG_INFO['Date'] == dt, 'revenue'].squeeze()
    }

# %% ../nbs/04_model.ipynb 34
@patch
def update_Ccum(self:Model, t, dt, S_t, x_t, theta):
    ## dow, hod = ((t + 1)//24)%7, (t + 1)%24; ##print(f'{dow=}, {hod=}')
    ## dow, qod = ((t + 1)//96)%7, (t + 1)%96; ##print(f'{dow=}, {qod=}')
    dow, sod = ((t + 1)//self.params.SLOTS_PER_DAY)%7, (t + 1)%self.params.SLOTS_PER_DAY; ##print(f'{dow=}, {sod=}')
    m1 = \
      x_t['xAlloc_t'].merge(
      S_t['R_t']\
       [['RCumSlots_t', 'RAvail_t', 'RCumMerits_t']],
       left_index=True, right_index=True)

    ## merge in previous allocations
    m1a = \
      S_t['xAlloc_t_1'].merge(
      m1[['Allocd_t', 'RCumSlots_t', 'RAvail_t', 'RCumMerits_t']],
      left_index=True, right_index=True)
    m1a.rename(columns={'Allocd_t_x': 'Allocd_t_1', 'Allocd_t_y': 'Allocd_t'}, inplace=True)

    m2 = \
      m1a.merge(
      cf.SICK_PROBS[[dt.month_name()]],
      left_index=True, right_index=True)
    m2.rename(columns={dt.month_name(): 'SickProb'}, inplace=True)

    m2['Capacity'] = pd.DataFrame({'Capacity': self.params.get_capacities(dow)})
    m2['Ccum_CumSlots'] = -(m2['RCumSlots_t'] - m2['Capacity'])

    ## m2['Ccum_SickProb'] = -100*m2['SickProb']
    ## m2['Ccum_SickProb'] = -100*(m2['SickProb'] - m2['SickProb'].mean()) ##100 makes values more comparable with other component of Ccum
    m2['Ccum_SickProb'] = -1*(m2['SickProb'] - m2['SickProb'].mean()) ##100 makes values more comparable with other component of Ccum

    m2['Ccum_CumMerits'] = m2['RCumMerits_t']

    m2.loc[ ## contiguous slots
      (m2['Allocd_t'] == True) & \
      (m2['Allocd_t'] == m2['Allocd_t_1']),
      ['Ccum_ContSlots']
    ] = cf.CONTIGUOUS_REWARD ## reward if shift is continued without interuption

    summables = m2.loc[
      m2['Allocd_t'] == True,
      ['Ccum_CumSlots', 'Ccum_SickProb', 'Ccum_CumMerits', 'Ccum_ContSlots'],
    ]
    Ccum_CumSlots, Ccum_SickProb, Ccum_CumMerits, Ccum_ContSlots = summables.sum(axis=0)
    Ccum = \
      theta.thCumSlots*Ccum_CumSlots + \
      theta.thSickProb*Ccum_SickProb + \
      theta.thCumMerits*Ccum_CumMerits + \
      theta.thContSlots*Ccum_ContSlots
    self.Ccum_CumSlots += Ccum_CumSlots
    self.Ccum_SickProb += Ccum_SickProb
    self.Ccum_CumMerits += Ccum_CumMerits
    self.Ccum_ContSlots += Ccum_ContSlots
    self.Ccum += Ccum

    ##resource expense (what you pay them)
    tmp = x_t['xAlloc_t'].loc[
      x_t['xAlloc_t']['Allocd_t'] == True,
    ]
    tmp = tmp.copy()
    tmp['type'] = tmp.apply(lambda row: row.Comb.split('_')[0], axis=1)
    tmp['expense'] = tmp.apply(lambda row: self.params.RESOURCE_EXPENSE[row.type], axis=1)
    expense = tmp['expense'].sum()
    self.Ccum -= expense
    
    ## real revenue or forecast
    self.Ccum += self.W_tt1['revenue']

# %% ../nbs/04_model.ipynb 41
@patch
def performAllocDecision(self:Model, S_t, x_t, theta):
    ## find list of ResourceIds for allocs from x_t
    resourceIds = x_t['xAlloc_t'].loc[
      x_t['xAlloc_t']['Allocd_t']==True,
      ['Comb']
    ]['Comb'].str.split('_').str[1:2].tolist(); ##print(f'{resourceIds=}')
    resourceIds_flat = [e[0] for e in resourceIds]; ##print(f'{resourceIds_flat=}')

    ## update state of allocs
    S_t['R_t'].loc[
      S_t['R_t']['ResourceId'].isin(resourceIds_flat),
      ['RAvail_t']
    ] = 0
    S_t['R_t'].loc[
      S_t['R_t']['ResourceId'].isin(resourceIds_flat),
      ['RCumSlots_t']
    ] += 1

    ## update Ccum with allocations
    ## self.Ccum += len(resourceIds_flat) #number of allocations

# %% ../nbs/04_model.ipynb 42
@patch
def S__M_fn(self:Model, t, dt, S_t, x_t, W_tt1, theta):
    ## dow, hod = ((t + 1)//24)%7, (t + 1)%24; ##print(f'{dow=}, {hod=}')
    ## dow, qod = ((t + 1)//96)%7, (t + 1)%96; ##print(f'{dow=}, {qod=}')
    dow, sod = ((t + 1)//self.params.SLOTS_PER_DAY)%7, (t + 1)%self.params.SLOTS_PER_DAY; ##print(f'{dow=}, {sod=}')

    ## perform decision taken this morning
    self.performAllocDecision(S_t, x_t, theta)

    ## Update state from exogenous information
    for an in self.params.aNAMES:
      resId = an.split('_')[1]
      merits = W_tt1['merits'][an]
      S_t['M_t'].loc[S_t['M_t']['ResourceId'] == resId, 'nMerits_t'] = merits
    S_t['R_t']['RAvail_t'] = W_tt1['availabilities']
    ## base demands
    for rt in self.params.RESOURCE_TYPES:
      rt_demands = W_tt1['demands'][rt]
      S_t['D_t'].loc[S_t['D_t']['Type'] == rt, 'DSlot_t'] = rt_demands
    ## busyness demands  
    busyness = W_tt1['busyness'] 
    S_t['B_t']['Busy_t'] = busyness
    for rt in self.params.RESOURCE_TYPES:
      rt_demands = self.params.DEMAND_PER_BUSYNESS[rt]*busyness
      S_t['D_t'].loc[S_t['D_t']['Type'] == rt, 'DBusy_t'] = rt_demands
    ## volume demands
    volume = W_tt1['volume'] 
    S_t['V_t']['Volume_t'] = volume
    for rt in self.params.RESOURCE_TYPES:
      rt_demands = self.params.DEMAND_PER_VOLUME[rt]*volume
      S_t['D_t'].loc[S_t['D_t']['Type'] == rt, 'DVolume_t'] = rt_demands
    ## revenue demands
    revenue = W_tt1['revenue']
    S_t['N_t']['Revenue_t'] = revenue
    for rt in self.params.RESOURCE_TYPES:
      rt_demands = self.params.DEMAND_PER_REVENUE[rt]*revenue
      S_t['D_t'].loc[S_t['D_t']['Type'] == rt, 'DRevenue_t'] = rt_demands    

    for rt in self.params.RESOURCE_TYPES:
      number = S_t['D_t'].loc[
        S_t['D_t']['Type']==rt,
        ['DSlot_t', 'DBusy_t', 'DVolume_t', 'DRevenue_t']
      ].max(axis=1).squeeze() ##max the contributions of each demand
      ## ].sum(axis=1).squeeze() ##sum the contributions of each demand
      S_t['D_t'].loc[S_t['D_t']['Type'] == rt, 'DMax_t'] = number

    ## Update cumulative merits of all resources
    S_t['R_t']['RCumMerits_t'] += S_t['M_t']['nMerits_t']

    ## Update RComplete_t
    m1 = \
      S_t['xAlloc_t_1'].merge(
      x_t['xAlloc_t'],
      left_index=True, right_index=True)
    m1.rename(columns={'Comb_x': 'Comb', 'Allocd_t_x': 'Allocd_t_1', 'Allocd_t_y': 'Allocd_t'}, inplace=True)
    m1.drop('Comb_y', inplace=True, axis=1)
    m2 = m1.loc[(m1['Allocd_t_1'] == True) & (m1['Allocd_t'] == False)]
    resourceIds = m2.loc[
      (m2['Allocd_t_1'] == True) & (m2['Allocd_t'] == False),
      ['Comb']
    ]['Comb'].str.split('_').str[1:2].tolist(); ##print(f'{resourceIds=}')
    resourceIds_flat = [e[0] for e in resourceIds]; ##print(f'{resourceIds_flat=}')
    S_t['R_t'].loc[
      S_t['R_t']['ResourceId'].isin(resourceIds_flat),
      ['RComplete_t']
    ] = 1

    ## Update 'xAlloc_t_1'
    S_t['xAlloc_t_1'] = copy(x_t['xAlloc_t']) ## SG

    # ## Reset for new month
    # if dt.is_month_start:
    #   S_t['R_t']['RMonthCumSlots_t'] = 0

    # ## Reset for new week
    # if dow == 0:
    #   S_t['R_t']['RMonthCumSlots_t'] += S_t['R_t']['RWeekCumSlots_t']
    #   S_t['R_t']['RWeekCumSlots_t'] = 0

    ## Reset for new day
    if sod == 0: ## slot-of-day
      S_t['R_t']['RCumSlots_t'] = 0; ##print(f'%%% Resetting RCumSlots_t ...')
      ## S_t['R_t']['RWeekCumSlots_t'] += S_t['R_t']['RCumSlots_t']
      ## S_t['R_t']['RCumSlots_t'] = 0; ##print(f'%%% Resetting RCumSlots_t ...')

      S_t['R_t']['RComplete_t'] = 0
      self.Ucum = {rt: 0 for rt in self.params.RESOURCE_TYPES}
      self.Ucum_Total = 0
      self.Ccum_CumSlots = 0.0
      ## self.Ccum_SickProb = 0.0
      ## self.Ccum_CumMerits = 0.0
      self.Ccum_ContSlots = 0.0
      ## self.Ccum = 0.0

    record_t = [t, dt] + \
      list(S_t['R_t']['RAvail_t']) + \
      list(S_t['R_t']['RCumSlots_t']) + \
      list(S_t['R_t']['RCumMerits_t']) + \
      list(S_t['R_t']['RComplete_t']) + \
      list(S_t['D_t']['DSlot_t']) + \
      list(S_t['D_t']['DBusy_t']) + \
      list(S_t['D_t']['DVolume_t']) + \
      list(S_t['D_t']['DRevenue_t']) + \
      list(S_t['D_t']['DMax_t']) + \
      list(S_t['B_t']['Busy_t']) + \
      list(S_t['V_t']['Volume_t']) + \
      list(S_t['N_t']['Revenue_t']) + \
      [self.Ucum[rt] for rt in self.params.RESOURCE_TYPES] + \
      [self.Ucum_Total] + \
      [self.Ccum_CumSlots] + \
      [self.Ccum_SickProb] + \
      [self.Ccum_CumMerits] + \
      [self.Ccum_ContSlots] + \
      [self.Ccum] + \
      list(x_t['xAlloc_t']['Allocd_t'])
    return record_t

# %% ../nbs/04_model.ipynb 43
@patch
def C_fn(self:Model, S_t, x_t, W_tt1, theta):
    return

# %% ../nbs/04_model.ipynb 44
@patch
def step(self:Model, t, dt, theta):
    ## IND = '\t\t'
    ## print(f"{IND}..... M. step() .....\n{t=}\n{theta=}")
    self.W_tt1 = self.W_fn(t, dt); ##print(f'%%% {W_tt1=}')

    ## update state & reward
    record_t = self.S__M_fn(t, dt, self.S_t, self.x_t, self.W_tt1, theta)
    # print(f'~~~~~~~~~~~~~ len(record_t): {len(record_t)}')
    # print(f'~~~~~~~~~~~~~ len(self.params.LABELS): {len(self.params.LABELS)}')    
    return record_t
